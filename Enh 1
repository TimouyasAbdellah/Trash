Pour faire en sorte que la sélection d'une case à cocher entraîne la sélection des cases à cocher des éléments enfants (et petits-enfants, le cas échéant), nous devons ajouter une méthode pour propager la sélection des parents vers les enfants et les petits-enfants. Nous devons également mettre à jour le modèle de données pour qu'il prenne en compte l'état des cases à cocher.

### TypeScript pour le Tree Table (Mise à jour)

Modifiez le fichier `tree-table.component.ts` pour ajouter la logique de propagation des sélections :

```typescript
import { Component } from '@angular/core';

interface PeriodicElement {
  name: string;
  weight: number;
  symbol: string;
  checked?: boolean;
  children?: PeriodicElement[];
}

const ELEMENT_DATA: PeriodicElement[] = [
  {
    name: 'Hydrogen', weight: 1.0079, symbol: 'H', checked: false, children: [
      {
        name: 'Hydrogen-1', weight: 1.0078, symbol: 'H1', checked: false, children: [
          { name: 'Hydrogen-1a', weight: 1.0077, symbol: 'H1a', checked: false },
          { name: 'Hydrogen-1b', weight: 1.0076, symbol: 'H1b', checked: false }
        ]
      },
      {
        name: 'Hydrogen-2', weight: 2.0141, symbol: 'H2', checked: false, children: [
          { name: 'Hydrogen-2a', weight: 2.0140, symbol: 'H2a', checked: false }
        ]
      }
    ]
  },
  { name: 'Helium', weight: 4.0026, symbol: 'He', checked: false },
  {
    name: 'Lithium', weight: 6.941, symbol: 'Li', checked: false, children: [
      {
        name: 'Lithium-1', weight: 6.015, symbol: 'Li1', checked: false, children: [
          { name: 'Lithium-1a', weight: 6.0149, symbol: 'Li1a', checked: false }
        ]
      },
      {
        name: 'Lithium-2', weight: 7.016, symbol: 'Li2', checked: false, children: [
          { name: 'Lithium-2a', weight: 7.0159, symbol: 'Li2a', checked: false },
          { name: 'Lithium-2b', weight: 7.0158, symbol: 'Li2b', checked: false }
        ]
      }
    ]
  }
];

@Component({
  selector: 'app-tree-table',
  templateUrl: './tree-table.component.html',
  styleUrls: ['./tree-table.component.css']
})
export class TreeTableComponent {
  dataSource = ELEMENT_DATA;
  selectedRowIndex: number | null = null;
  selectedChildIndex: { parentIndex: number, childIndex: number } | null = null;
  selectedGrandChildIndex: { parentIndex: number, childIndex: number, grandChildIndex: number } | null = null;

  addRow() {
    const newRow: PeriodicElement = {
      name: `New Element ${this.dataSource.length + 1}`,
      weight: 0,
      symbol: '',
      checked: false
    };
    this.dataSource.unshift(newRow);
  }

  addChild() {
    const newChild: PeriodicElement = {
      name: `New Child ${Date.now()}`,
      weight: 0,
      symbol: '',
      checked: false
    };

    if (this.selectedGrandChildIndex !== null) {
      // Do nothing, adding a child to a grandchild is not allowed
    } else if (this.selectedChildIndex !== null) {
      const { parentIndex, childIndex } = this.selectedChildIndex;
      this.dataSource[parentIndex].children![childIndex].children = this.dataSource[parentIndex].children![childIndex].children || [];
      this.dataSource[parentIndex].children![childIndex].children!.push(newChild);
    } else if (this.selectedRowIndex !== null) {
      this.dataSource[this.selectedRowIndex].children = this.dataSource[this.selectedRowIndex].children || [];
      this.dataSource[this.selectedRowIndex].children!.push(newChild);
    }
  }

  selectRow(parentIndex: number, childIndex?: number, grandChildIndex?: number) {
    this.selectedRowIndex = parentIndex;
    this.selectedChildIndex = childIndex !== undefined ? { parentIndex, childIndex } : null;
    this.selectedGrandChildIndex = (childIndex !== undefined && grandChildIndex !== undefined) ? { parentIndex, childIndex, grandChildIndex } : null;
  }

  propagateSelection(element: PeriodicElement, checked: boolean) {
    element.checked = checked;
    if (element.children) {
      element.children.forEach(child => this.propagateSelection(child, checked));
    }
  }

  toggleSelection(parentIndex: number, childIndex?: number, grandChildIndex?: number) {
    if (grandChildIndex !== undefined) {
      const grandChild = this.dataSource[parentIndex].children![childIndex!].children![grandChildIndex];
      this.propagateSelection(grandChild, !grandChild.checked);
    } else if (childIndex !== undefined) {
      const child = this.dataSource[parentIndex].children![childIndex];
      this.propagateSelection(child, !child.checked);
    } else {
      const parent = this.dataSource[parentIndex];
      this.propagateSelection(parent, !parent.checked);
    }
  }

  moveUp() {
    if (this.selectedGrandChildIndex !== null) {
      const { parentIndex, childIndex, grandChildIndex } = this.selectedGrandChildIndex;
      if (grandChildIndex > 0) {
        const temp = this.dataSource[parentIndex].children![childIndex].children![grandChildIndex];
        this.dataSource[parentIndex].children![childIndex].children![grandChildIndex] = this.dataSource[parentIndex].children![childIndex].children![grandChildIndex - 1];
        this.dataSource[parentIndex].children![childIndex].children![grandChildIndex - 1] = temp;
        this.selectedGrandChildIndex.grandChildIndex--;
      }
    } else if (this.selectedChildIndex !== null) {
      const { parentIndex, childIndex } = this.selectedChildIndex;
      if (childIndex > 0) {
        const temp = this.dataSource[parentIndex].children![childIndex];
        this.dataSource[parentIndex].children![childIndex] = this.dataSource[parentIndex].children![childIndex - 1];
        this.dataSource[parentIndex].children![childIndex - 1] = temp;
        this.selectedChildIndex.childIndex--;
      }
    } else if (this.selectedRowIndex !== null && this.selectedRowIndex > 0) {
      const temp = this.dataSource[this.selectedRowIndex];
      this.dataSource[this.selectedRowIndex] = this.dataSource[this.selectedRowIndex - 1];
      this.dataSource[this.selectedRowIndex - 1] = temp;
      this.selectedRowIndex--;
    }
  }

  moveDown() {
    if (this.selectedGrandChildIndex !== null) {
      const { parentIndex, childIndex, grandChildIndex } = this.selectedGrandChildIndex;
      if (grandChildIndex < this.dataSource[parentIndex].children![childIndex].children!.length - 1) {
        const temp = this.dataSource[parentIndex].children![childIndex].children![grandChildIndex];
        this.dataSource[parentIndex].children![childIndex].children![grandChildIndex] = this.dataSource[parentIndex].children![childIndex].children![grandChildIndex + 1];
        this.dataSource[parentIndex].children![childIndex].children![grandChildIndex + 1] = temp;
        this.selectedGrandChildIndex.grandChildIndex++;
      }
    } else if (this.selectedChildIndex !== null) {
      const { parentIndex, childIndex } = this.selectedChildIndex;
      if (childIndex < this.dataSource[parentIndex].children!.length - 1) {
        const temp = this.dataSource[parentIndex].children![childIndex];
        this.dataSource[parentIndex].children![childIndex] = this.dataSource[parentIndex].children![childIndex + 1];
        this.dataSource[parentIndex].children![childIndex + 1] = temp;
        this.selectedChildIndex.childIndex++;
      }
    } else if (this.selectedRowIndex !== null && this.selectedRowIndex < this.dataSource.length - 1) {
      const temp = this.dataSource[this.selectedRowIndex];
      this.dataSource[this.selectedRowIndex] = this.dataSource[this.selectedRowIndex + 1];
      this.dataSource[this.selectedRowIndex + 1] = temp;
      this.selectedRowIndex++;
    }
  }
}
```

### HTML pour le Tree Table (Mise à jour)

Modifiez le fichier `tree-table.component.html` pour appeler `toggleSelection` lorsque l'utilisateur clique sur une case à cocher :

```html
<div class="mb-3">
  <button class="btn btn-primary" (click)="addRow()">Add Row</button>
  <button class="btn btn-info" (click)="moveUp()" [disabled]="selectedRowIndex === null || selectedRowIndex === 0">Move Up</button>
  <button class="btn btn-info" (click)="moveDown()" [disabled]="selectedRowIndex === null || selectedRowIndex === dataSource.length - 1
